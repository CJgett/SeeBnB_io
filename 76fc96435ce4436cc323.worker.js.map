{"version":3,"sources":["webpack://lib/webpack/bootstrap","webpack://lib/./src/constants.js","webpack://lib/./src/solvers/cost.js","webpack://lib/./src/solvers/data-structures/Edge.js","webpack://lib/./src/solvers/data-structures/PriorityQueue.js","webpack://lib/./src/solvers/data-structures/Queue.js","webpack://lib/./src/solvers/data-structures/Stack.js","webpack://lib/./src/solvers/data-structures/TreeNode.js","webpack://lib/./src/solvers/exhaustive/bnbHelpers.js","webpack://lib/./src/solvers/exhaustive/branchAndBoundOnCost.worker.js","webpack://lib/./src/solvers/makeSolver.js","webpack://lib/./src/store/actions.js","webpack://lib/./src/store/emitCustomEvent.js"],"names":["START_POINT_COLOR","POINT_COLOR","BEST_PATH_COLOR","EVALUATING_PATH_COLOR","EVALUATING_ERROR_COLOR","EVALUATING_SEGMENT_COLOR","COLOR_MODE_KEY","distance","pt1","pt2","lng1","lat1","lng2","lat2","radlat1","Math","PI","radlat2","theta","radtheta","dist","sin","cos","acos","pathCost","path","slice","map","point","idx","reduce","a","b","counterClockWise","p","q","r","intersects","c","d","setDifference","setA","setB","ret","Set","forEach","delete","rotateToStartingPoint","startingPoint","startIdx","findIndex","unshift","splice","length","Edge","constructor","pointA","pointB","lowerBound","next","PriorityQueue","head","last","size","push","node","prevHead","beforeInsert","afterInsert","headsOrTails","pop","copy","priorityQueueCopy","nodeToCopy","Queue","oldLast","Stack","oldHead","TreeNode","costToPoint","pathIncludingPoint","hasPoint","i","createEdgePriorityQueue","points","edges","pointsAsArray","Array","from","j","edgeToAdd","calculateLowerBound","boundingStrategy","cheapestEdgesLowerBound","edgesToAdd","startCheckingHere","edgesCopy","nextEdge","containsEdge","oneTreeLowerBound","currentEdge","pointsToBuildMST","selectMSTPoints","pointToIndexMap","Map","index","set","join","groupRepArray","counter","edgeIncludesForbiddenPoint","nodesAreConnected","updateGroupReps","edge","firstPointID","get","secondPointID","firstPointGroupRepID","findGroupRep","secondPointGroupRepID","pointID","currentPointID","pointsToUse","pointsAreEqual","allPoints","selectedPoints","edgePointA","edgePointB","initializeToVisit","searchStrategy","toVisit","createPointToNameMap","uniquePointString","toString","findNodeWithPath","tree","pointToNameMap","nodeToFind","children","name","makeNode","cost","exploring","isCurrentBest","wrapSolver","solver","args","self","postMessage","actions","makeSolver","run","solverConfig","detailLevel","delay","fullSpeed","stepping","bestCostFromHeuristic","Number","POSITIVE_INFINITY","paused","setBestPath","setEvaluatingPaths","getPaths","level","round","paths","updateTree","setEvaluatingPath","getPath","waitPause","Promise","resolve","setTimeout","sleep","duration","saveRunDetails","row","onmessage","data","action","type","evaluatingDetailLevel","initialSolution","instance","runID","Error","SET_VIEWPORT_STATE","UPDATE_TREE","UPDATE_NUM_NODES","UPDATE_RUN_TABLE","RESET_RUN_TABLE","RESET_EVALUATING_STATE","RESET_BEST_PATH_STATE","SET_INITIAL_SOLUTION","SET_SEARCH_STRATEGY","SET_BOUNDING_STRATEGY","SET_ALGORITHM","SET_ALGORITHM_TYPE","SET_ALGORITHM_STAGE","SET_DELAY","SET_EVALUATING_DETAIL_LEVEL","SET_SHOW_BEST_PATH","START_SOLVING","GO_FULL_SPEED","GO_STEP_BY_STEP","STOP_STEPPING","PAUSE","UNPAUSE","STOP_SOLVING","SET_BEST_PATH","SET_EVALUATING_PATHS","START_DEFINING_POINTS","ADD_DEFINED_POINT","STOP_DEFINING_POINTS","SET_POINT_COUNT","SET_POINTS","SET_TABLE_INSTANCE","SET_DEFAULT_MAP","SET_DROPDOWN_MAP","TOGGLE_SITE_INFO_OPEN","TOGGLE_ALG_INFO_OPEN","TOGGLE_INSTANCE_INFO_OPEN","TOGGLE_EXPANDED_TREE_OPEN","getRandomPoint","max","min","random","toggleSiteInfoOpen","toggleAlgInfoOpen","toggleInstanceInfoOpen","toggleExpandedTreeOpen","setViewportState","viewport","numNodes","updateNumNodes","updateRunTable","resetRunTable","resetEvaluatingStateAction","resetBestPathStateAction","setInitialSolutionAction","defaults","setSearchStrategyAction","setBoundingStrategyAction","setAlgorithmAction","algorithm","setAlgorithmTypeAction","algorithmType","setAlgorithmStage","isRunningBnB","startSolvingAction","stopSolvingAction","setAlgorithm","dispatch","setAlgorithmType","setInitialSolution","setSearchStrategy","setBoundingStrategy","setDelay","setEvaluatingDetailLevel","setShowBestPath","show","resetSolverState","stopSolving","startSolving","getState","pointCount","bestCost","gtmEmit","event","goFullSpeed","goStepByStep","stopStepping","pause","unpause","setDefaultMapAction","setTableInstance","setDropdownMapAction","setPointsAction","setPointCountAction","count","startDefiningPointsAction","startDefiningPoints","addDefinedPoint","stopDefiningPoints","setPointCount","randomizePoints","bounds","top","bottom","left","right","_","Date","now","setDefaultMap","setDropdownMap","ev","window","dataLayer","console","log"],"mappings":"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","file":"76fc96435ce4436cc323.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/solvers/exhaustive/branchAndBoundOnCost.worker.js\");\n","// orangish\nexport const START_POINT_COLOR = [255, 87, 34];\n\n// blueish\nexport const POINT_COLOR = [41, 121, 255];\n\n// greenish\nexport const BEST_PATH_COLOR = [76, 175, 80];\n\n// orangish\nexport const EVALUATING_PATH_COLOR = [255, 87, 34, 225];\n\n// reddish\nexport const EVALUATING_ERROR_COLOR = [255, 25, 25, 240];\n\n// greyish\nexport const EVALUATING_SEGMENT_COLOR = [180, 180, 180, 240];\n\nexport const COLOR_MODE_KEY = \"color-mode\";\n","// haversine great circle distance\nexport const distance = (pt1, pt2) => {\n  const [lng1, lat1] = pt1;\n  const [lng2, lat2] = pt2;\n  if ((lat1 === lat2 && lng1 === lng2) || (pt1 === pt2)) {\n    return 0;\n  }\n\n  var radlat1 = (Math.PI * lat1) / 180;\n  var radlat2 = (Math.PI * lat2) / 180;\n\n  var theta = lng1 - lng2;\n  var radtheta = (Math.PI * theta) / 180;\n\n  var dist =\n    Math.sin(radlat1) * Math.sin(radlat2) +\n    Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n\n  if (dist > 1) {\n    dist = 1;\n  }\n  dist = Math.acos(dist);\n  dist = (dist * 180) / Math.PI;\n  return dist * 60 * 1.1515 * 1.609344;\n};\n\nexport const pathCost = path => {\n  return path\n    .slice(0, -1)\n    .map((point, idx) => distance(point, path[idx + 1]))\n    .reduce((a, b) => a + b, 0);\n};\n\nexport const counterClockWise = (p, q, r) => {\n  return (q[0] - p[0]) * (r[1] - q[1]) < (q[1] - p[1]) * (r[0] - q[0]);\n};\n\nexport const intersects = (a, b, c, d) => {\n  return (\n    counterClockWise(a, c, d) !== counterClockWise(b, c, d) &&\n    counterClockWise(a, b, c) !== counterClockWise(a, b, d)\n  );\n};\n\nexport const setDifference = (setA, setB) => {\n  const ret = new Set(setA);\n  setB.forEach(p => {\n    ret.delete(p);\n  });\n  return ret;\n};\n\nexport const rotateToStartingPoint = (path, startingPoint) => {\n  const startIdx = path.findIndex(p => p === startingPoint);\n  path.unshift(...path.splice(startIdx, path.length));\n};\n\n","export class Edge {\n  constructor(pointA, pointB, lowerBound) {\n    this.pointA = pointA \n    this.pointB = pointB\n    this.lowerBound = lowerBound \n    this.next = null\n  }\n}\n","// use for mlb. Queue is sorted according to generalized cost value\n// (called lowerBound, but can also be distance)\nexport class PriorityQueue {\n  constructor() {\n    this.head = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  push(node) {\n    // case: pq is empty\n    if(this.head === null) {\n      this.head = node;\n      this.last = node;\n    }\n    // case: pq has one entry. Insert node either before or after node and update head/last accordingly\n    else if (this.head === this.last) {\n      if (this.head.lowerBound < node.lowerBound) {\n        this.head.next = node;\n        this.last = node;\n      } else {\n        let prevHead = this.head\n        this.head = node\n        this.head.next = prevHead\n        this.last = prevHead\n      }\n    // case: pq has more than one entry. find before insertion point. edge cases: insertion point is head/last\n    } else {\n      let beforeInsert = this.head;\n      let afterInsert = this.head.next;\n      let headsOrTails = 0;\n      while(afterInsert !== null && afterInsert.lowerBound < node.lowerBound) {\n        beforeInsert = beforeInsert.next;\n        afterInsert = afterInsert.next;\n        ++headsOrTails;\n      }\n      if (headsOrTails === 0 && beforeInsert.lowerBound > node.lowerBound) {\n        this.head = node;\n        this.head.next = beforeInsert;\n      } else if (headsOrTails === this.size - 1) {\n        beforeInsert.next = node;\n        this.last = node;\n      } else {\n        beforeInsert.next = node;\n        node.next = afterInsert;\n      }\n    }\n    return ++this.size;\n  }\n\n  pop() {\n    let prevHead = this.head;\n    if (this.head === null)\n      return null;\n    // priority queue has only one object and will be empty\n    if(this.head === this.last) {\n      this.last = null;\n    }  \n    this.head = this.head.next;\n    this.size--;\n    return prevHead;\n  }\n\n  copy() {\n    let priorityQueueCopy = new PriorityQueue();\n    let nodeToCopy = this.head;\n    while(nodeToCopy !== null) {\n      priorityQueueCopy.push(nodeToCopy);\n      nodeToCopy = nodeToCopy.next;\n    }\n    priorityQueueCopy.head = this.head;\n    priorityQueueCopy.last = this.last;\n    return priorityQueueCopy;\n  }\n}\n","// use for fifo/bfs \nexport class Queue {\n\n  constructor() {\n    this.head = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  push(node) {\n    if(this.head === null) {\n      this.head = node;\n      this.last = node;\n    } else {\n      let oldLast = this.last;\n      this.last = node;\n      oldLast.next = node;\n    }\n    return ++this.size;\n  }\n  \n  pop() {\n    let prevHead = this.head;\n    // queue has only one object and will be empty\n    if(this.head === this.last) { \n      this.last = null;\n    }\n    this.head = this.head.next;\n    this.size--;\n    return prevHead;\n  }\n}\n","// use for lifo/dfs\nexport class Stack {\n\n  constructor() {\n    this.head = null;\n    this.last = null;\n    this.size = 0;\n  }\n\n  push(node) {\n    if(this.head === null) {\n      this.head = node;\n      this.last = node;\n    } else {\n      let oldHead = this.head; \n      this.head = node;\n      this.head.next = oldHead;\n    }\n    return ++this.size;\n  }\n\n  pop() {\n    if(this.head === null) \n      return null;\n    let prevHead = this.head;\n    // stack has only one object and will be empty\n    if(this.head === this.last) {\n      this.last = null;\n    }\n    this.head = this.head.next;\n    this.size--;\n    return prevHead;\n  }\n\n}\n","export class TreeNode {\n  constructor(costToPoint, pathIncludingPoint, lowerBound) {\n    this.costToPoint = costToPoint;\n    this.pathIncludingPoint = pathIncludingPoint;\n    this.lowerBound = lowerBound; \n    this.next = null;\n  }\n}\n","import { PriorityQueue } from \"../data-structures/PriorityQueue\";\nimport { Queue } from \"../data-structures/Queue\";\nimport { Stack } from \"../data-structures/Stack\";\nimport { TreeNode } from \"../data-structures/TreeNode\";\nimport { Edge } from \"../data-structures/Edge\";\nimport { distance } from \"../cost\";\n\nexport function hasPoint(path, point) {\n  for(let i = 0; i < path.length; i++) {\n    if(\n      (path[i][0] === point[0] && path[i][1] === point[1]) || \n      (path[i][0] === point[1] && path[i][1] === point[0])) {\n      return true; }\n  }\n  return false;\n}\n\n// create priority queue of edges ordered by cost (low to high). Only needed for cheapest edges bounding strategy\nexport function createEdgePriorityQueue(points) {\n  let edges = new PriorityQueue();\n    let pointsAsArray = Array.from(points);\n    for (let i = 0; i < pointsAsArray.length; i++) {\n      for (let j = i+1; j < pointsAsArray.length; j++) {\n        let pointA = pointsAsArray[i];\n        let pointB = pointsAsArray[j];\n        let edgeToAdd = new Edge(pointA, pointB, distance(pointA, pointB));\n        edges.push(edgeToAdd);\n    }\n  }\n  return edges;\n} \n\n// returns the lower bound for the given path and cost\n// gives an anwswer to the question, \nexport function calculateLowerBound(costToPoint, pathIncludingPoint, points, boundingStrategy, edges) {\n  if (boundingStrategy === \"none\") {\n  }\n  if (boundingStrategy === \"cheapestEdges\") {\n    if(pathIncludingPoint.length === points.length){\n      return costToPoint;\n    }\n    // Add the cheapest edges that are not yet part of the given path, \n    // until as many edges have been selected as there are nodes. \n    let cheapestEdgesLowerBound = costToPoint;\n    let edgesToAdd = (points.length) - (pathIncludingPoint.length - 1);\n    let startCheckingHere = 0;\n    let edgesCopy = edges.copy();\n    let nextEdge = \"\";\n    while (edgesToAdd !== 0) {\n      nextEdge = edgesCopy.pop()\n      if (!containsEdge(pathIncludingPoint, nextEdge)) {\n        // although it's called \"nextEdge.lowerBound\", this is the distance cost for this edge!\n        cheapestEdgesLowerBound += nextEdge.lowerBound; \n        edgesToAdd--;\n      }\n    }\n    return cheapestEdgesLowerBound;\n  }\n  else if (boundingStrategy === \"oneTree\") {\n\n    if(pathIncludingPoint.length === points.length){\n      return costToPoint;\n    }\n    // this implementation of Kruskal uses a simplified union/find tactic\n    let oneTreeLowerBound = costToPoint;\n    let edgesToAdd = (points.length) - (pathIncludingPoint.length - 1);\n    let edgesCopy = edges.copy();\n    let currentEdge = \"\";\n    let pointsToBuildMST = selectMSTPoints(pathIncludingPoint, points);\n    const pointToIndexMap = new Map();\n    // save the values of pointsToBuild in a map, index -> point\n    pointsToBuildMST.forEach((point, index) => pointToIndexMap.set(point.join(','), index));\n    let groupRepArray = [];\n    // initialize the group representative for each point to be included in the MST. At the start, every point is its own representative\n    pointsToBuildMST.forEach((point, index) => groupRepArray[index] = index);\n\n    let counter = 0;\n\n    while (edgesToAdd !== 0) {\n      counter++;\n      currentEdge = edgesCopy.pop();\n      if(edgeIncludesForbiddenPoint(pointsToBuildMST, currentEdge)) {\n        // in this case, the currentEdge contains at least one point on the inner part of the current path, which we don't want to use for the MST.\n        continue;\n      }\n      if(pathIncludingPoint.length === 2 && containsEdge(pathIncludingPoint, currentEdge)) {\n        // edge case: even though we would normally ignore the portion of the current path between the start and end node by not including these points in the creation of the MST, in the case of the current path containing just two nodes, this edge needs to be manually ignored.\n        continue;\n      }\n      if(nodesAreConnected(currentEdge, groupRepArray, pointToIndexMap)) {\n        // nodes have the same group rep and are therefore connected through some path already. Adding this edge would create a cycle, which we don't want!\n          continue;\n      }\n      // updating one of the point's group rep to the point's group rep connects the two groups\n      updateGroupReps(currentEdge, groupRepArray, pointToIndexMap);\n      // add the edge to the mst, but we only need the lower bound, so just calculate this.\n      // currentEdge.lowerBound is actually the cost of the edge!\n      oneTreeLowerBound += currentEdge.lowerBound;\n      edgesToAdd--;\n    }\n    return oneTreeLowerBound;\n  }\n  // could add: boundingStrategy === \"oneTreeWithAscent\" \n  else {\n    return 0;\n  }\n}\nfunction updateGroupReps(edge, groupRepArray, pointToIndexMap) {\n  const firstPointID = pointToIndexMap.get(edge.pointA.join(',')); \n  const secondPointID = pointToIndexMap.get(edge.pointB.join(','));\n  const firstPointGroupRepID = findGroupRep(firstPointID, groupRepArray);\n  const secondPointGroupRepID = findGroupRep(secondPointID, groupRepArray);\n  groupRepArray[firstPointGroupRepID] = secondPointGroupRepID;\n}\n\nfunction nodesAreConnected(edge, groupRepArray, pointToIndexMap) {\n  const firstPointID = pointToIndexMap.get(edge.pointA.join(',')); \n  const secondPointID = pointToIndexMap.get(edge.pointB.join(','));\n  const firstPointGroupRepID = findGroupRep(firstPointID, groupRepArray);\n  const secondPointGroupRepID = findGroupRep(secondPointID, groupRepArray);\n  if (firstPointGroupRepID === secondPointGroupRepID) {\n    return true;\n  }\n  return false;\n}\n\nfunction findGroupRep(pointID, groupRepArray) {\n  let currentPointID = pointID;\n  while (currentPointID !== groupRepArray[pointID]) {\n    currentPointID = groupRepArray[pointID];\n  }\n  return currentPointID;\n}\nfunction edgeIncludesForbiddenPoint(pointsToUse, edge) {\n  if (!hasPoint(pointsToUse, edge.pointA) || !hasPoint(pointsToUse, edge.pointB)) {\n    return true;\n  }\n  return false;\n}\nfunction pointsAreEqual(pointA, pointB) {\n  if (pointA[0] === pointB[0] && pointA[1] === pointB[1]) {\n    return true;\n  }\n  else return false;\n}\nfunction selectMSTPoints(path, allPoints) {\n  if(path.length === 1) {\n    return allPoints;\n  }\n  let selectedPoints = [];\n  if(path.length === allPoints.length) {\n    return selectedPoints;\n  }\n  for (let i = 0; i < allPoints.length; i++) {\n    if (!hasPoint(path, allPoints[i]))\n      selectedPoints.push(allPoints[i]);\n  }\n  selectedPoints.push(path[0]);\n  selectedPoints.push(path[path.length - 1]);\n  return selectedPoints;\n}\n// returns whether a given path array contains an edge value\nexport function containsEdge(path, edge) {\n  let edgePointA = edge.pointA;\n  let edgePointB = edge.pointB;\n  for (let i = 0; i < path.length - 1 ; i++) {\n    if ((pointsAreEqual(edgePointA, path[i]) && pointsAreEqual(edgePointB, path[i+1])) || (pointsAreEqual(edgePointA, path[i+1]) && pointsAreEqual(edgePointB, path[i]))) {\n        return true;\n    }\n  }\n  return false;\n}\n\n// create the toVisit structure to hold nodes that still need to be explored\n// exact data structure type depends on the search strategy\nexport function initializeToVisit(searchStrategy) {\n  if (searchStrategy === \"lifo\")\n    var toVisit = new Stack();\n  else if (searchStrategy === \"fifo\")\n    var toVisit = new Queue();\n  else if (searchStrategy === \"mlb\")\n    var toVisit = new PriorityQueue();\n  return toVisit;\n}\n\n//\n// NODE TREE (displayed in bottom section)\n//\n\n// creates a map containing point-name pairs given an array of points \n// this is used to give the nodes their names (shown as labels inside nodes)\nexport function createPointToNameMap(points) {\n  var map = new Map();\n  var uniquePointString;\n  for(let i = 0; i < points.length; i++) {\n    uniquePointString = points[i].join(',');\n    map.set(uniquePointString, i.toString());\n  }\n  return map;\n}\n\n// find a node in the node tree given a path\nexport function findNodeWithPath(path, tree, pointToNameMap) {\n  if (path.length === 1)\n    return tree;\n  let nodeToFind = tree;\n  for (let i = 1; i < path.length; i++) {\n    for (let j = 0; j < nodeToFind.children.length; j++) {\n      if (pointToNameMap.get(path[i].join(',')) === nodeToFind.children[j].name) {\n        nodeToFind = nodeToFind.children[j];\n        break;\n      }\n    }\n  }\n  return nodeToFind;\n}\n\nexport function makeNode(name, cost, path, exploring, isCurrentBest) {\n  return {\n    \"name\" : name,\n    \"cost\" : cost,\n    \"path\" : path,\n    \"exploring\" : exploring,\n    \"isCurrentBest\" : isCurrentBest,\n    \"children\": []\n  };\n}\n","/* eslint-disable no-restricted-globals */\nimport makeSolver from \"../makeSolver\";\nimport { pathCost, setDifference, distance } from \"../cost\";\nimport { hasPoint, createEdgePriorityQueue, calculateLowerBound, initializeToVisit, createPointToNameMap, findNodeWithPath, makeNode } from \"./bnbHelpers\";\nimport { TreeNode } from \"../data-structures/TreeNode\";\n\nimport {\n  EVALUATING_PATH_COLOR,\n  EVALUATING_ERROR_COLOR,\n  EVALUATING_SEGMENT_COLOR\n} from \"../../constants\";\n\nconst branchAndBoundOnCost = async (\n  points,\n  bestCostFromHeuristic,\n  searchStrategy,\n  boundingStrategy,\n  // only need the following to display the run details...\n  initialSolution,\n  instance,\n  runID\n) => {\n  if(points.length < 2) {\n    return [0, points];\n  }\n\n  // initialize variables\n  \n  const startingPoint = points.slice(0).shift();\n\n  let overallBestCost = bestCostFromHeuristic || Infinity;\n  let overallBestPath = [];\n\n  // create priority queue of edges ordered by cost (low to high). \n  // Only needed for cheapest edges bounding strategy\n  const edges = createEdgePriorityQueue(points);\n\n  // this holds the nodes that need to still be explored\n  // the data structure depends on the search strategy\n  let toVisit = initializeToVisit(searchStrategy);\n  const initialCost = 0;\n  const initialPath = new Array(startingPoint);\n  const initialLowerBound = calculateLowerBound(initialCost, initialPath, points, boundingStrategy, edges);\n  toVisit.push(new TreeNode(initialCost, initialPath, initialLowerBound));\n\n  const pointToNameMap = createPointToNameMap(points);\n  \n  const rootNode = makeNode(\"0\", initialCost, initialPath, \"no\", \"no\");\n  var data = rootNode;\n  self.updateTree(data, 0);\n\n  let path = initialPath;\n  let cost = initialCost;\n  let lowerBound = 0;\n\n  // this value marks the node that will be visited in the current while loop\n  let currentNode = \"\";\n  let numNodesVisited = 0;    \n\n  while (toVisit.size !== 0) {\n    // delete the next node from toVisit \n    // determined by search strategy / data structure\n    currentNode = toVisit.pop();\n    path = currentNode.pathIncludingPoint;\n    cost = currentNode.costToPoint;\n    lowerBound = currentNode.lowerBound;\n\n    // highlight current node in NodeTree (bottom menu)\n    findNodeWithPath(path, data, pointToNameMap).exploring = \"yes\";\n    self.updateTree(data, numNodesVisited);\n\n    // the following displays the paths on the map\n    self.setEvaluatingPaths(\n      () => ({\n        paths: [\n          {\n            path: path.slice(0, path.length - 1),\n            color: EVALUATING_SEGMENT_COLOR\n          },\n          {\n            path: path.slice(path.length - 2, path.length + 1),\n            color: EVALUATING_ERROR_COLOR\n          }\n        ],\n        cost\n      }),\n      lowerBound, 2\n    );\n    await self.sleep();\n   \n    if (currentNode.lowerBound > overallBestCost || currentNode.costToPoint > overallBestCost) {\n      // cases 1 & 2: minimumLowerBound > overallBestCost; currentCost > overallBestCost\n      // node should be pruned, lower branches ignored (currentNode deleted & no new nodes added to toVisit)\n    } else if (currentNode.pathIncludingPoint.length === points.length) {\n      // case 3: finished path \n      //     case 3.1: cost > overallBestCost (already covered above)\n      //     case 3.2: cost < overallBestCost\n      let lastPointAddedToPath = currentNode.pathIncludingPoint[currentNode.pathIncludingPoint.length - 1];\n      let costBackToStart = currentNode.costToPoint + distance(lastPointAddedToPath, startingPoint);\n      let pathBackToStart =  [...currentNode.pathIncludingPoint, startingPoint];\n\n      if (costBackToStart <= overallBestCost) {\n        // if there is a previous current best, stop showing the highlight in the tree\n        if (overallBestPath.length !== 0) {\n           findNodeWithPath(overallBestPath, data, pointToNameMap).isCurrentBest = \"no\";\n        }\n        overallBestCost = costBackToStart;\n        overallBestPath = pathBackToStart;\n        findNodeWithPath(path, data, pointToNameMap).isCurrentBest = \"yes\";\n        self.setBestPath(overallBestPath, overallBestCost);\n      }\n    } else {\n    // case 4: unfinished path, but still worth searching \n    // (current node is already delete from toVisit, make sure node values are \n    // added to currentCost and currentPath! Then add next nodes to end of toVisit) \n      for (let i = 0; i < points.length; i++) {\n        if (!hasPoint(currentNode.pathIncludingPoint, points[i])) { \n          let lastPointAddedToPath = currentNode.pathIncludingPoint[currentNode.pathIncludingPoint.length - 1];\n          let distanceToNewNode = distance(lastPointAddedToPath, points[i])\n          let costToNewPoint = currentNode.costToPoint + distanceToNewNode;\n          let pathIncludingNewPoint = [...currentNode.pathIncludingPoint, points[i]];\n          let newPointLowerBound = calculateLowerBound(costToNewPoint, pathIncludingNewPoint, points, boundingStrategy, edges);\n          toVisit.push(new TreeNode(costToNewPoint, pathIncludingNewPoint, newPointLowerBound));\n\n          // add nodes to NodeTree (bottom section) too!\n          const newDisplayTreeNode = makeNode(i.toString(), costToNewPoint, pathIncludingNewPoint, \"no\", \"no\");\n          findNodeWithPath(path, data, pointToNameMap).children.push(newDisplayTreeNode);\n        }\n      }\n    }\n    findNodeWithPath(path, data, pointToNameMap).exploring = \"no\";\n    if(numNodesVisited < 1000) {\n      self.updateTree(data, numNodesVisited);\n    }\n    numNodesVisited++;\n  }\n\n  // stop displaying evaluating path \n  path = initialPath;\n  cost = initialCost;\n  self.setEvaluatingPaths(\n    () => ({\n      paths: [\n        {\n          path: path.slice(0, path.length - 1),\n          color: EVALUATING_SEGMENT_COLOR\n        },\n        {\n          path: path.slice(path.length - 2, path.length + 1),\n          color: EVALUATING_ERROR_COLOR\n        }\n      ],\n      cost\n    }),\n    null, 2\n  );\n\n  await self.sleep();\n\n  const roundedOverallBestCost = Math.round(overallBestCost * 100) / 100;\n\n  self.saveRunDetails({\n  \"runID\": runID,\n  \"runDetails\": `${initialSolution}, ${searchStrategy}, ${boundingStrategy}`,\n  \"solution\": `${roundedOverallBestCost}`,\n  \"instance\": `${instance}`,\n  \"evalNodes\": `${numNodesVisited}`,\n});\n\n  return [overallBestCost, overallBestPath];\n};\n\nmakeSolver(branchAndBoundOnCost);\n","/* eslint-disable no-restricted-globals */\nimport * as actions from \"../store/actions\";\n\nconst wrapSolver = solver => async (...args) => {\n  await solver(...args);\n  self.postMessage(actions.stopSolvingAction());\n  self.postMessage(actions.setAlgorithmStage(\"toggle\"));\n};\n\nexport const makeSolver = solver => {\n  const run = wrapSolver(solver);\n\n  self.solverConfig = {\n    detailLevel: 0,\n    delay: 10,\n    fullSpeed: false,\n    stepping: true,\n    bestCostFromHeuristic: Number.POSITIVE_INFINITY,\n    paused: false\n  };\n\n  self.setBestPath = (...args) => {\n    self.postMessage(actions.setBestPath(...args));\n  };\n\n  self.setEvaluatingPaths = (getPaths, lowerBound = null, level = 1) => {\n    if (lowerBound !== null) {\n      lowerBound = Math.round(lowerBound * 100) / 100;\n    }\n    if (self.solverConfig.detailLevel >= level) {\n      const { paths, cost } = getPaths();\n      self.postMessage(actions.setEvaluatingPaths(paths, cost, lowerBound));\n    }\n  };\n\n  self.updateTree = (...args) => {\n    self.postMessage(actions.updateTree(...args));\n  };\n\n  self.setEvaluatingPath = (getPath, level = 1) => {\n    if (self.solverConfig.detailLevel >= level) {\n      const { path, cost } = getPath();\n      self.postMessage(actions.setEvaluatingPath(path, cost));\n    }\n  };\n\n  self.waitPause = async () => {\n    while (self.solverConfig.paused) {\n      await new Promise(resolve => setTimeout(resolve, 500));\n    }\n  };\n\n  self.sleep = async () => {\n    if (self.solverConfig.stepping) {\n      self.postMessage(actions.pause());\n      self.solverConfig.paused = true;\n    }\n    if (self.solverConfig.paused) {\n      return await self.waitPause();\n    }\n\n    const duration = self.solverConfig.fullSpeed\n      ? 0\n      : self.solverConfig.delay || 10;\n    return new Promise(resolve => {\n      setTimeout(resolve, duration);\n    });\n  };\n\n  self.saveRunDetails = (row) => {\n    self.postMessage(actions.updateRunTable(row));\n  };\n\n  self.onmessage = async ({ data: action }) => {\n    switch (action.type) {\n      case actions.START_SOLVING:\n        self.solverConfig.delay = action.delay;\n        self.solverConfig.detailLevel = action.evaluatingDetailLevel;\n        self.solverConfig.fullSpeed = action.fullSpeed;\n        self.solverConfig.stepping = action.stepping;\n        self.solverConfig.bestCostFromHeuristic = action.bestCostFromHeuristic;\n        self.solverConfig.paused = false;\n        run(action.points, action.bestCostFromHeuristic, action.searchStrategy, action.boundingStrategy, action.initialSolution, action.instance, action.runID);\n        break;\n\n      case actions.SET_DELAY:\n        self.solverConfig.delay = action.delay;\n        break;\n\n      case actions.SET_EVALUATING_DETAIL_LEVEL:\n        self.solverConfig.detailLevel = action.level;\n        break;\n\n      case actions.GO_FULL_SPEED:\n        self.solverConfig.evaluatingDetailLevel = 0;\n        self.solverConfig.fullSpeed = true;\n        break;\n\n    case actions.GO_STEP_BY_STEP:\n        self.solverConfig.stepping = true;\n        break;\n\n      case actions.STOP_STEPPING:\n        self.solverConfig.stepping = false;\n\n      case actions.PAUSE:\n        self.solverConfig.paused = true;\n        break;\n\n      case actions.UNPAUSE:\n        self.solverConfig.paused = false;\n        break;\n\n      default:\n        throw new Error(`invalid action sent to solver ${action.type}`);\n    }\n  };\n};\n\nexport default makeSolver;\n","import gtmEmit from \"./emitCustomEvent\";\nexport const SET_VIEWPORT_STATE = \"SET_VIEWPORT_STATE\";\n\nexport const UPDATE_TREE = \"UPDATE_TREE\";\nexport const UPDATE_NUM_NODES = \"UPDATE_NUM_NODES\";\nexport const UPDATE_RUN_TABLE = \"UPDATE_RUN_TABLE\";\nexport const RESET_RUN_TABLE = \"RESET_RUN_TABLE\";\n\nexport const RESET_EVALUATING_STATE = \"RESET_EVALUATING_STATE\";\nexport const RESET_BEST_PATH_STATE = \"RESET_BEST_PATH_STATE\";\n\nexport const SET_INITIAL_SOLUTION = \"SET_INITIAL_SOLUTION\";\nexport const SET_SEARCH_STRATEGY = \"SET_SEARCH_STRATEGY\";\nexport const SET_BOUNDING_STRATEGY = \"SET_BOUNDING_STRATEGY\";\nexport const SET_ALGORITHM = \"SET_ALGORITHM\";\nexport const SET_ALGORITHM_TYPE = \"SET_ALGORITHM_TYPE\";\nexport const SET_ALGORITHM_STAGE = \"SET_ALGORITHM_STAGE\";\nexport const SET_DELAY = \"SET_DELAY\";\nexport const SET_EVALUATING_DETAIL_LEVEL = \"SET_EVALUATING_DETAIL_LEVEL\";\nexport const SET_SHOW_BEST_PATH = \"SET_SHOW_BEST_PATH\";\nexport const START_SOLVING = \"START_SOLVING\";\nexport const GO_FULL_SPEED = \"GO_FULL_SPEED\";\nexport const GO_STEP_BY_STEP = \"GO_STEP_BY_STEP\";\nexport const STOP_STEPPING = \"STOP_STEPPING\";\nexport const PAUSE = \"PAUSE\";\nexport const UNPAUSE = \"UNPAUSE\";\nexport const STOP_SOLVING = \"STOP_SOLVING\";\n\nexport const SET_BEST_PATH = \"SET_BEST_PATH\";\nexport const SET_EVALUATING_PATHS = \"SET_EVALUATING_PATHS\";\n\nexport const START_DEFINING_POINTS = \"START_DEFINING_POINTS\";\nexport const ADD_DEFINED_POINT = \"ADD_DEFINED_POINT\";\nexport const STOP_DEFINING_POINTS = \"STOP_DEFINING_POINTS\";\nexport const SET_POINT_COUNT = \"SET_POINT_COUNT\";\nexport const SET_POINTS = \"SET_POINTS\";\nexport const SET_TABLE_INSTANCE = \"SET_TABLE_INSTANCE\";\nexport const SET_DEFAULT_MAP = \"SET_DEFAULT_MAP\";\nexport const SET_DROPDOWN_MAP = \"SET_DROPDOWN_MAP\";\n\nexport const TOGGLE_SITE_INFO_OPEN = \"TOGGLE_SITE_INFO_OPEN\";\nexport const TOGGLE_ALG_INFO_OPEN = \"TOGGLE_ALG_INFO_OPEN\";\nexport const TOGGLE_INSTANCE_INFO_OPEN = \"TOGGLE_INSTANCE_INFO_OPEN\";\nexport const TOGGLE_EXPANDED_TREE_OPEN = \"TOGGLE_EXPANDED_TREE_OPEN\";\n\nconst getRandomPoint = (max, min) => Math.random() * (max - min) + min;\n\n//\n// BASIC UI\n//\nexport const toggleSiteInfoOpen = () => ({\n  type: TOGGLE_SITE_INFO_OPEN\n});\n\nexport const toggleAlgInfoOpen = () => ({\n  type: TOGGLE_ALG_INFO_OPEN\n});\n\nexport const toggleInstanceInfoOpen = () => ({\n  type: TOGGLE_INSTANCE_INFO_OPEN\n});\n\nexport const toggleExpandedTreeOpen = () => ({\n  type: TOGGLE_EXPANDED_TREE_OPEN\n});\n\n//\n// MAP INTERACTION\n//\nexport const setViewportState = viewport => ({\n  type: SET_VIEWPORT_STATE,\n  viewport\n});\n\n//\n// BOTTOM MENU \n//\nexport const updateTree = (tree, numNodes) => ({\n  type: UPDATE_TREE,\n  tree,\n  numNodes\n});\n\nexport const updateNumNodes = numNodes => ({\n  type: UPDATE_NUM_NODES,\n  numNodes\n});\n\nexport const updateRunTable = row => ({\n  type: UPDATE_RUN_TABLE,\n  row \n});\n\nexport const resetRunTable = () => ({\n  type: RESET_RUN_TABLE\n});\n\n//\n// SOLVER CONTROLS\n//\nconst resetEvaluatingStateAction = () => ({\n  type: RESET_EVALUATING_STATE\n});\n\nconst resetBestPathStateAction = () => ({\n  type: RESET_BEST_PATH_STATE\n});\n\nconst setInitialSolutionAction = (initialSolution, defaults) => ({\n  type: SET_INITIAL_SOLUTION,\n  initialSolution,\n  defaults\n});\n\nconst setSearchStrategyAction = (searchStrategy, defaults) => ({\n  type: SET_SEARCH_STRATEGY,\n  searchStrategy,\n  defaults\n});\n\nconst setBoundingStrategyAction = (boundingStrategy, defaults) => ({\n  type: SET_BOUNDING_STRATEGY,\n  boundingStrategy,\n  defaults\n});\n\nconst setAlgorithmAction = (algorithm, defaults) => ({\n  type: SET_ALGORITHM,\n  algorithm,\n  defaults\n});\n\nconst setAlgorithmTypeAction = (algorithmType, defaults) => ({\n  type: SET_ALGORITHM_TYPE,\n  algorithmType,\n  defaults\n});\n\n// this EITHER toggles based on what the current value is OR sets the stage to isRunningBnB (boolean, when true, then run BranchAndBound, otherwise run heuristic)\nexport const setAlgorithmStage = (isRunningBnB) => ({\n  type: SET_ALGORITHM_STAGE,\n  isRunningBnB \n});\n\nexport const startSolvingAction = (points, delay, evaluatingDetailLevel, stepping, bestCostFromHeuristic, searchStrategy, boundingStrategy, initialSolution, instance, runID) => ({\n  type: START_SOLVING,\n  points,\n  delay,\n  fullSpeed: false,\n  evaluatingDetailLevel,\n  stepping,\n  bestCostFromHeuristic,\n  searchStrategy,\n  boundingStrategy,\n  initialSolution,\n  instance,\n  runID\n});\n\nexport const stopSolvingAction = () => ({\n  type: STOP_SOLVING\n});\n\nexport const setAlgorithm = (algorithm, defaults = {}) => dispatch => {\n  dispatch(resetEvaluatingStateAction());\n  dispatch(setAlgorithmAction(algorithm, defaults));\n};\n\nexport const setAlgorithmType = (algorithmType) => dispatch => {\n  dispatch(resetEvaluatingStateAction());\n  dispatch(setAlgorithmTypeAction(algorithmType));\n};\n\nexport const setInitialSolution = (initialSolution, defaults = {}) => dispatch => {\n  dispatch(resetEvaluatingStateAction());\n  dispatch(setInitialSolutionAction(initialSolution, defaults));\n};\n\nexport const setSearchStrategy = (searchStrategy, defaults = {}) => dispatch => {\n  dispatch(resetEvaluatingStateAction());\n  dispatch(setSearchStrategyAction(searchStrategy, defaults));\n};\n\nexport const setBoundingStrategy = (boundingStrategy, defaults = {}) => dispatch => {\n  dispatch(resetEvaluatingStateAction());\n  dispatch(setBoundingStrategyAction(boundingStrategy, defaults));\n};\n\nexport const setDelay = delay => ({\n  type: SET_DELAY,\n  delay\n});\n\nexport const setEvaluatingDetailLevel = level => ({\n  type: SET_EVALUATING_DETAIL_LEVEL,\n  level\n});\n\nexport const setShowBestPath = show => ({\n  type: SET_SHOW_BEST_PATH,\n  show\n});\n\nexport const resetSolverState = () => dispatch => {\n  dispatch(stopSolving());\n  dispatch(resetEvaluatingStateAction());\n  dispatch(resetBestPathStateAction());\n  dispatch(setAlgorithmStage(false));\n};\n\nexport const startSolving = (...args) => (dispatch, getState) => {\n  const { initialSolution, pointCount, algorithm, evaluatingDetailLevel, bestCost } = getState();\n  gtmEmit({\n    event: \"start-solving\",\n    initialSolution,\n    algorithm,\n    pointCount,\n    evaluatingDetailLevel,\n    bestCost\n  });\n  dispatch(startSolvingAction(...args));\n};\n\nexport const goFullSpeed = () => ({\n  type: GO_FULL_SPEED\n});\n\nexport const goStepByStep = () => ({\n  type: GO_STEP_BY_STEP\n});\n\nexport const stopStepping = () => ({\n  type: STOP_STEPPING\n});\n\nexport const pause = () => ({\n  type: PAUSE\n});\n\nexport const unpause = () => ({\n  type: UNPAUSE\n});\n\nexport const stopSolving = () => dispatch => {\n  dispatch(resetEvaluatingStateAction());\n  dispatch(stopSolvingAction());\n};\n\n//\n// SOLVER ACTIONS\n//\nexport const setEvaluatingPath = (path, cost) => ({\n  type: SET_EVALUATING_PATHS,\n  paths: [path],\n  cost\n});\n\nexport const setEvaluatingPaths = (paths, cost, lowerBound) => ({\n  type: SET_EVALUATING_PATHS,\n  paths,\n  cost,\n  lowerBound\n});\n\nexport const setBestPath = (path, cost) => ({\n  type: SET_BEST_PATH,\n  path,\n  cost\n});\n\n//\n// POINT CONTROLS\n//\nconst setDefaultMapAction = () => ({\n  type: SET_DEFAULT_MAP\n});\n\nexport const setTableInstance = (instance) => ({\n  type: SET_TABLE_INSTANCE,\n  instance\n});\n\nconst setDropdownMapAction = (instance) => ({\n  type: SET_DROPDOWN_MAP,\n  instance\n});\n\nconst setPointsAction = points => ({\n  type: SET_POINTS,\n  points\n});\n\nconst setPointCountAction = count => ({\n  type: SET_POINT_COUNT,\n  count\n});\n\nconst startDefiningPointsAction = () => ({\n  type: START_DEFINING_POINTS\n});\n\nexport const startDefiningPoints = () => dispatch => {\n  dispatch(resetSolverState());\n  dispatch(startDefiningPointsAction());\n};\n\nexport const addDefinedPoint = point => ({\n  type: ADD_DEFINED_POINT,\n  point\n});\n\nexport const stopDefiningPoints = () => ({\n  type: STOP_DEFINING_POINTS\n});\n\nexport const setPointCount = count => dispatch => {\n  dispatch(resetSolverState());\n  dispatch(setPointCountAction(count));\n};\n\nexport const randomizePoints = bounds => (dispatch, getState) => {\n  const { pointCount } = getState();\n  const { top, bottom, left, right } = bounds;\n  const points = Array.from({ length: pointCount }).map(_ => [\n    getRandomPoint(right, left),\n    getRandomPoint(top, bottom)\n  ]);\n  const instance = pointCount + \"nodes_\" + Date.now().toString().slice(8);\n  dispatch(resetSolverState());\n  dispatch(setPointsAction(points));\n  dispatch(setTableInstance(instance));\n};\n\nexport const setDefaultMap = (...args) => dispatch => {\n  dispatch(resetSolverState());\n  dispatch(setDefaultMapAction());\n};\n\nexport const setDropdownMap = (instance) => dispatch => {\n  dispatch(resetSolverState());\n  dispatch(setDropdownMapAction(instance));\n  dispatch(setTableInstance(instance));\n};\n","export default ev => {\n  if (typeof window !== \"undefined\" && window.dataLayer) {\n    window.dataLayer.push(ev);\n  } else {\n    console.log(ev);\n  }\n};\n"],"sourceRoot":""}